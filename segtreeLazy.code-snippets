{
	"": {
		"prefix": "segtreeLazy",
		"body": [
		  "struct segtree_lazy",
		  "{",
		  "    //initialise the tree with size",
		  "    //do updates for each array element",
		  "    //do the queries",
		  "    //you can do operation of one type and query of some another type",
		  "    long long size;",
		  "    long long NO_OPEERATION = LLONG_MAX;   //** this should be 0 in case of sums and LLONG_MAX for assignment and similar for max assignment etc.",
		  "    long long NEUTRAL_ELEMENT = LLONG_MAX; //** for minimum (not neccesarily)",
		  "",
		  "    vector<long long> opr, tree; //in operations you store operations and in tree you can store values of segtree",
		  "",
		  "    long long modify_op(ll a, ll b, ll len) //to be used in operations or tree, len is the number of array node covered by current segtree node",
		  "    {",
		  "        if (b == NO_OPEERATION)",
		  "            return a;",
		  "        return b*len; //** b*len for assignment operation, a+b*len for sums and so on...",
		  "    }",
		  "    long long calc(ll a, ll b) //to be used in tree",
		  "    {",
		  "        return min(a,b);",
		  "    }",
		  "",
		  "    void init(ll n)",
		  "    {",
		  "        size = 1;",
		  "        while (size < n)",
		  "        {",
		  "            size *= 2;",
		  "        }",
		  "        tree.assign(2 * size, 0); //** (SHOULD BE 0 FOR MIN) you might need to change this depending on what needs to be assigned initially to the array",
		  "        opr.assign(2 * size, NO_OPEERATION); //**",
		  "    }",
		  "",
		  "    void build(ve <ll> &arr,ll x,ll lx,ll rx)//you may not always need the build function ",
		  "    {",
		  "        if (lx==rx)",
		  "        {",
		  "            tree[x]=arr[lx];//make sure this dosent go out of bounds...",
		  "            return;",
		  "        }",
		  "        ll mid = (lx + rx) / 2;",
		  "        build(arr, 2 * x + 1, lx, mid);",
		  "        build(arr, 2 * x + 2, mid + 1, rx);",
		  "        tree[x] = calc(tree[2 * x + 1], tree[2 * x + 2]);",
		  "    }",
		  "    void build(ve <ll> &arr)",
		  "    {",
		  "        //the size of the array need not always be S.size it can be something different as well, tc of it in build.",
		  "        build(arr,0,0,(int)arr.size()-1);",
		  "    }",
		  "    void propogate(ll x, ll lx, ll rx)",
		  "    {",
		  "        if (rx == lx)",
		  "            return; //if it is leaf no need for propogation",
		  "        ll mid = (lx + rx) / 2;",
		  "        opr[2 * x + 1] = modify_op(opr[2 * x + 1], opr[x], 1);",
		  "        opr[2 * x + 2] = modify_op(opr[2 * x + 2], opr[x], 1);",
		  "        tree[2 * x + 1] = modify_op(tree[2 * x + 1], opr[x], mid - lx + 1); //since an  operation is propogated the values corresponding to the nodes where operation is propogated must change in the tree",
		  "        tree[2 * x + 2] = modify_op(tree[2 * x + 2], opr[x], rx - (mid+1) + 1);",
		  "        opr[x] = NO_OPEERATION;",
		  "    }",
		  "",
		  "    //we are going from lx to rx both included, change all values in l to r to val",
		  "    void range_update(ll l, ll r, ll val, ll x, ll lx, ll rx)",
		  "    {",
		  "        propogate(x, lx, rx);",
		  "        if (lx > r || l > rx)",
		  "            return;",
		  "        if (lx >= l && rx <= r)",
		  "        {",
		  "            opr[x] = modify_op(opr[x], val, 1);",
		  "            tree[x] = modify_op(tree[x], val, rx - lx + 1);",
		  "            return;",
		  "        }",
		  "        ll mid = (lx + rx) / 2;",
		  "        range_update(l, r, val, 2 * x + 1, lx, mid);",
		  "        range_update(l, r, val, 2 * x + 2, mid + 1, rx);",
		  "        tree[x] = calc(tree[2 * x + 1], tree[2 * x + 2]); //we need to recalculate values in tree as per the changes in the values in our tree due to newly added operations",
		  "    }",
		  "    void range_update(ll l, ll r, ll val)",
		  "    {",
		  "        range_update(l, r, val, 0, 0, size - 1);",
		  "    }",
		  "    long long query(ll l, ll r, ll x, ll lx, ll rx)",
		  "    {",
		  "        propogate(x, lx, rx);",
		  "        if (lx > r || l > rx)",
		  "            return NEUTRAL_ELEMENT;",
		  "        if (lx >= l && rx <= r)",
		  "            return tree[x];",
		  "        ll mid = (lx + rx) / 2;",
		  "        ll left = query(l, r, 2 * x + 1, lx, mid);",
		  "        ll right = query(l, r, 2 * x + 2, mid + 1, rx);",
		  "        ll res = calc(left, right);",
		  "        return res;",
		  "    }",
		  "    long long query(ll l, ll r)",
		  "    {",
		  "        return query(l, r, 0, 0, size - 1);",
		  "    }",
		  "};"
		],
		"description": ""
	  }
}